<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Visual Hopfield Network: Live Tuning</title>
    <style>
        :root {
            --bg-primary: #193549;
            --bg-secondary: #002240;
            --bg-tertiary: #25435A;
            --fg-primary: #FFFFFF;
            --fg-secondary: #97B1C2;
            --accent: #ffab40;
            --accent-fg: #002240;
            --error: #FF628C;
            --log-color: #F1FA8C;

            --dot-excite: #2ecc71;
            --dot-inhibit: #e74c3c;
        }
        body {
            font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            background-color: var(--bg-secondary);
            color: var(--fg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 2rem;
        }
        h1 {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--accent);
        }
        .subtitle { font-size: 0.9em; color: var(--fg-secondary); margin-bottom: 20px; }
        
        .main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
            width: 100%;
            margin-bottom: 20px; /* Space for the console */
            max-width: 1000px; /* Constrain max width for large screens */
        }

        .panel {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--bg-tertiary);
            text-align: center;
        }

        canvas {
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            image-rendering: pixelated; /* Ensures crisp pixels */
            image-rendering: crisp-edges;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
        }

        button {
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }
        button:hover { filter: brightness(1.2); transform: translateY(-1px); }
        button:active { transform: translateY(1px); }

        .btn-learn { background: var(--accent); color: var(--accent-fg); }
        .btn-noise { background: var(--fg-secondary); color: var(--accent-fg); }
        .btn-run { background: var(--bg-tertiary); color: var(--fg-primary); }
        .btn-clear { background: var(--error); color: var(--fg-primary); }
        .btn-forget { background: var(--accent); color: var(--accent-fg); filter: brightness(0.7); }

        .stats {
            margin-top: 15px;
            text-align: left;
            font-size: 12px;
            color: var(--fg-secondary);
            border-top: 1px solid var(--bg-tertiary);
            padding-top: 10px;
        }
        .stat-val { float: right; color: var(--fg-primary); }

        /* Legend for the graph */
        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            font-size: 10px;
            margin-top: 5px;
        }
        .legend span { display: flex; align-items: center; gap: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    </style>
    <style>
        /* Console Styles */
        .console-panel {
            width: 100%;
            max-width: 1000px;
            height: 180px;
            background: var(--bg-primary);
            border-radius: 12px;
            border: 1px solid var(--bg-tertiary);
            display: flex;
            flex-direction: column;
        }
        .console-header {
            background: var(--bg-tertiary);
            padding: 5px 15px;
            font-weight: bold;
            color: var(--accent);
            border-top-left-radius: 11px;
            border-top-right-radius: 11px;
            font-size: 12px;
        }
        .console-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: "Consolas", "Monaco", monospace;
            font-size: 11px;
            color: var(--log-color);
        }
    </style>
    <script>
        // Developer: Prathamesh Deshmukh
    </script>
</head>
<body>

    <h1>VISUAL HOPFIELD NET</h1>
    <div class="subtitle">
        5x5 Grid (25 Neurons) | Fully Connected Graph | Developed by Prathamesh Deshmukh
    </div>

    <div class="main-container">
        
        <div class="panel">
            <h3>INPUT GRID</h3>
            <canvas id="gridCanvas" width="200" height="200"></canvas>
            <div style="margin-top:10px; font-size:12px; color:var(--fg-secondary)">Click to toggle pixels</div>
        </div>

        <div class="panel">
            <h3>NEURAL NETWORK VIEW</h3>
            <canvas id="netCanvas" width="400" height="400"></canvas>
            <div class="legend">
                <span><span class="dot" style="background:var(--dot-excite)"></span> Excitation (+)</span>
                <span><span class="dot" style="background:var(--dot-inhibit)"></span> Inhibition (-)</span>
            </div>
        </div>

        <div class="panel controls">
            <button class="btn-learn" onclick="learn()">1. Learn Pattern</button>
            <button class="btn-forget" onclick="forget()">2. Forget Pattern</button>
            <button class="btn-clear" onclick="clearGrid()">3. Clear Grid</button>
            <hr style="border-color:var(--bg-tertiary); width:100%">
            <button class="btn-noise" onclick="addNoise()">4. Add Noise</button>
            <button class="btn-run" onclick="recover(250)">5. Run</button>
            
            <div class="stats">
                <div>Energy: <span id="energy" class="stat-val">0.0</span></div>
                <div>Stable: <span id="stable" class="stat-val">Yes</span></div>
                <div>Patterns: <span id="pCount" class="stat-val">0</span></div>
            </div>
        </div>
    </div>

    <!-- CONSOLE LOG -->
    <div class="console-panel">
        <div class="console-header">EVENT LOG</div>
        <div id="console-log" class="console-content">
        </div>
    </div>

<script>
    // --- CONFIG ---
    const N_SIDE = 5; // 5x5 grid
    const N = N_SIDE * N_SIDE; // 25 Neurons
    const CANVAS_GRID_SIZE = 200;
    const CANVAS_NET_SIZE = 400;
    
    // --- STATE ---
    // Neurons: -1 (Off) or 1 (On)
    let neurons = new Array(N).fill(-1);
    // Weights: N x N matrix
    let weights = Array.from({ length: N }, () => new Array(N).fill(0));
    let storedPatterns = 0;

    // --- DOM ---
    const gridCtx = document.getElementById('gridCanvas').getContext('2d');
    const netCtx = document.getElementById('netCanvas').getContext('2d');
    const energyEl = document.getElementById('energy');
    const stableEl = document.getElementById('stable');
    const countEl = document.getElementById('pCount');
    const consoleLogEl = document.getElementById('console-log');

    // --- PRE-CALCULATE NETWORK LAYOUT (Circular) ---
    const nodePositions = [];
    const centerX = CANVAS_NET_SIZE / 2;
    const centerY = CANVAS_NET_SIZE / 2;
    const radius = 160;

    for (let i = 0; i < N; i++) {
        const angle = (i / N) * 2 * Math.PI - Math.PI/2; // Start at top
        nodePositions.push({
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
        });
    }

    // --- LOGGING ---
    function logMessage(message) {
        const time = new Date().toLocaleTimeString();
        const msgDiv = document.createElement('div');
        msgDiv.innerHTML = `<span style="color:var(--fg-secondary)">[${time}]</span> ${message}`;
        consoleLogEl.appendChild(msgDiv);
        // Auto-scroll to the bottom
        consoleLogEl.scrollTop = consoleLogEl.scrollHeight;
    }


    // --- DRAWING FUNCTIONS ---

    function drawGrid() {
        const cellSize = CANVAS_GRID_SIZE / N_SIDE;
        // Set the black background explicitly
        gridCtx.fillStyle = '#000';
        gridCtx.fillRect(0, 0, CANVAS_GRID_SIZE, CANVAS_GRID_SIZE);
        
        // 1. Draw the neuron states first
        for (let i = 0; i < N; i++) {
            const x = (i % N_SIDE) * cellSize;
            const y = Math.floor(i / N_SIDE) * cellSize;
            
            // "Off" pixels are black, "On" pixels are white
            gridCtx.fillStyle = neurons[i] === 1 ? 'white' : 'black';
            gridCtx.fillRect(x, y, cellSize, cellSize);
        }

        // 2. Draw white grid lines on top
        gridCtx.strokeStyle = 'white';
        gridCtx.lineWidth = 1;
        for (let i = 1; i < N_SIDE; i++) {
            // Vertical lines
            gridCtx.beginPath();
            gridCtx.moveTo(i * cellSize, 0);
            gridCtx.lineTo(i * cellSize, CANVAS_GRID_SIZE);
            gridCtx.stroke();
            // Horizontal lines
            gridCtx.beginPath();
            gridCtx.moveTo(0, i * cellSize);
            gridCtx.lineTo(CANVAS_GRID_SIZE, i * cellSize);
            gridCtx.stroke();
        }
    }

    function drawNetwork() {
        netCtx.clearRect(0, 0, CANVAS_NET_SIZE, CANVAS_NET_SIZE);
        
        // 1. Draw Connections (Weights)
        // Optimization: Only draw weights with magnitude > 0
        for (let i = 0; i < N; i++) {
            for (let j = i + 1; j < N; j++) { // Undirected graph, draw once
                const w = weights[i][j];
                if (Math.abs(w) > 0.1) {
                    const pos1 = nodePositions[i];
                    const pos2 = nodePositions[j];
                    
                    netCtx.beginPath();
                    netCtx.moveTo(pos1.x, pos1.y);
                    netCtx.lineTo(pos2.x, pos2.y);
                    
                    // Color: Green for positive (same state), Red for negative (diff state)
                    netCtx.strokeStyle = w > 0 ? 'rgba(46, 204, 113, ' + Math.min(Math.abs(w)/N*4, 0.7) + ')' 
                                               : 'rgba(231, 76, 60, ' + Math.min(Math.abs(w)/N*4, 0.7) + ')';
                    
                    netCtx.lineWidth = Math.min(Math.abs(w)/2, 3);
                    netCtx.stroke();
                }
            }
        }

        // 2. Draw Nodes
        for (let i = 0; i < N; i++) {
            const pos = nodePositions[i];
            netCtx.beginPath();
            netCtx.arc(pos.x, pos.y, 8, 0, 2 * Math.PI);
            // Node color matches state: White (On) or Dark Gray (Off)
            netCtx.fillStyle = neurons[i] === 1 ? '#fff' : '#333';
            netCtx.fill(); 
            netCtx.strokeStyle = '#fff';
            netCtx.lineWidth = 1;
            netCtx.stroke();
            
            // Highlight node index (optional)
            // netCtx.fillStyle = 'red';
            // netCtx.fillText(i, pos.x, pos.y);
        }
        
        calculateEnergy();
    }

    function calculateEnergy() {
        let E = 0;
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
                E += weights[i][j] * neurons[i] * neurons[j];
            }
        }
        E = -0.5 * E;
        energyEl.innerText = E.toFixed(1);
    }

    // --- INTERACTION ---

    document.getElementById('gridCanvas').addEventListener('mousedown', (e) => {
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const cellSize = CANVAS_GRID_SIZE / N_SIDE;
        
        const col = Math.floor(x / cellSize);
        const row = Math.floor(y / cellSize);
        const idx = row * N_SIDE + col;
        
        if (idx >= 0 && idx < N) {
            neurons[idx] *= -1;
            drawGrid();
            drawNetwork();
            logMessage(`User toggled neuron ${idx} to state ${neurons[idx] > 0 ? 'ON' : 'OFF'}.`);
            stableEl.innerText = "No";
        }
    });

    // --- LOGIC ---

    function learn() {
        // Hebbian Learning: w_ij += s_i * s_j
        // Animate the "tuning" process
        let i = 0;
        const btn = document.querySelector('.btn-learn');
        btn.disabled = true;
        btn.innerText = "Tuning...";
        logMessage("Starting Hebbian learning for current pattern...");

        function stepLearn() {
            // Process one row at a time for animation speed
            for (let j = 0; j < N; j++) {
                if (i === j) continue;
                weights[i][j] += neurons[i] * neurons[j];
                // Keep weights symmetric
                weights[j][i] = weights[i][j]; 
                
                // Zero diagonal
                if (i==j) weights[i][j] = 0;
            }
            
            drawNetwork();
            i++;
            
            if (i < N) {
                requestAnimationFrame(stepLearn);
            } else {
                storedPatterns++;
                countEl.innerText = storedPatterns;
                btn.disabled = false;
                btn.innerText = "1. Learn Pattern";
                logMessage(`Pattern learned. Total patterns stored: ${storedPatterns}.`);
                stableEl.innerText = "Yes (Learned)";
            }
        }
        stepLearn();
    }

    function forget() {
        // Hebbian Anti-Learning: w_ij -= s_i * s_j
        if (storedPatterns <= 0) {
            logMessage("Forget failed: No patterns stored.");
            countEl.innerText = "0";
            return; // Nothing to forget
        }

        let i = 0;
        const btn = document.querySelector('.btn-forget');
        btn.disabled = true;
        btn.innerText = "Forgetting...";
        logMessage("Starting anti-learning to forget current pattern...");

        function stepForget() {
            for (let j = 0; j < N; j++) {
                if (i === j) continue;
                weights[i][j] -= neurons[i] * neurons[j];
                weights[j][i] = weights[i][j]; // Keep symmetric
            }
            
            drawNetwork();
            i++;
            
            if (i < N) {
                requestAnimationFrame(stepForget);
            } else {
                storedPatterns--;
                countEl.innerText = storedPatterns;
                btn.disabled = false;
                btn.innerText = "2. Forget Pattern";
                logMessage(`Pattern forgotten. Total patterns remaining: ${storedPatterns}.`);
            }
        }
        stepForget();
    }

    function addNoise() {
        // Flip 20% of bits
        let flippedCount = 0;
        for (let i = 0; i < N; i++) {
            if (Math.random() < 0.2) {
                neurons[i] *= -1;
                flippedCount++;
            }
        }
        drawGrid();
        drawNetwork();
        logMessage(`Added noise: ${flippedCount} neuron(s) flipped.`);
        stableEl.innerText = "Unstable";
    }

    function clearGrid() {
        neurons.fill(-1);
        drawGrid();
        drawNetwork();
        logMessage("Grid cleared to all OFF state.");
        stableEl.innerText = "-";
    }

    async function recover(delay) {
        const btn = document.querySelector('.btn-run');
        btn.disabled = true;
        btn.innerText = "Running...";
        logMessage(`Starting recovery process with ${delay}ms delay...`);
        
        let stable = false;
        let iter = 0;
        
        // We run for a max number of steps to prevent infinite loops if spurious states
        const MAX_STEPS = 50; 
        
        while (!stable && iter < MAX_STEPS) {
            logMessage(`--- Iteration ${iter + 1} ---`);
            stable = true;
            // Create a random order to update neurons (Asynchronous update)
            const indices = Array.from({length: N}, (_, i) => i);
            indices.sort(() => Math.random() - 0.5);
            
            for (let k = 0; k < N; k++) {
                const idx = indices[k];
                let sum = 0;
                for (let j = 0; j < N; j++) {
                    sum += weights[idx][j] * neurons[j];
                }
                
                const newState = sum >= 0 ? 1 : -1;
                
                if (newState !== neurons[idx]) {
                    neurons[idx] = newState;
                    stable = false;
                    logMessage(`Neuron ${idx} flipped to ${newState > 0 ? 'ON' : 'OFF'}.`);
                    
                    // Animate every flip
                    drawGrid();
                    drawNetwork();
                    await new Promise(r => setTimeout(r, delay)); // Delay for visual effect
                }
            }
            iter++;
        }
        
        btn.disabled = false;
        btn.innerText = "5. Run";
        const endState = stable ? "Converged" : "Stopped";
        stableEl.innerText = endState;
        if (stable) {
            logMessage(`Recovery complete: Network converged to a stable state.`);
        } else {
            logMessage(`Recovery stopped: Reached max iterations (${MAX_STEPS}).`);
        }
    }

    // Init
    drawGrid();
    drawNetwork();
    logMessage("Hopfield network initialized.");

</script>
</body>
</html>